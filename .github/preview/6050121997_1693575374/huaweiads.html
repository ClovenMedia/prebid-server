
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>huaweiads: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/prebid/prebid-server/adapters/huaweiads/huaweiads.go (90.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package huaweiads

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/prebid/openrtb/v19/native1"
        nativeRequests "github.com/prebid/openrtb/v19/native1/request"
        nativeResponse "github.com/prebid/openrtb/v19/native1/response"
        "github.com/prebid/openrtb/v19/openrtb2"
        "github.com/prebid/prebid-server/adapters"
        "github.com/prebid/prebid-server/config"
        "github.com/prebid/prebid-server/errortypes"
        "github.com/prebid/prebid-server/openrtb_ext"
)

const huaweiAdxApiVersion = "3.4"
const defaultCountryName = "ZA"
const defaultUnknownNetworkType = 0
const timeFormat = "2006-01-02 15:04:05.000"
const defaultTimeZone = "+0200"
const defaultModelName = "HUAWEI"
const chineseSiteEndPoint = "https://acd.op.hicloud.com/ppsadx/getResult"
const europeanSiteEndPoint = "https://adx-dre.op.hicloud.com/ppsadx/getResult"
const asianSiteEndPoint = "https://adx-dra.op.hicloud.com/ppsadx/getResult"
const russianSiteEndPoint = "https://adx-drru.op.hicloud.com/ppsadx/getResult"

// creative type
const (
        text                   int32 = 1
        bigPicture             int32 = 2
        bigPicture2            int32 = 3
        gif                    int32 = 4
        videoText              int32 = 6
        smallPicture           int32 = 7
        threeSmallPicturesText int32 = 8
        video                  int32 = 9
        iconText               int32 = 10
        videoWithPicturesText  int32 = 11
)

// interaction type
const (
        appPromotion int32 = 3
)

// ads type
const (
        banner       int32 = 8
        native       int32 = 3
        roll         int32 = 60
        interstitial int32 = 12
        rewarded     int32 = 7
        splash       int32 = 1
        magazinelock int32 = 2
        audio        int32 = 17
)

type huaweiAdsRequest struct {
        Version           string     `json:"version"`
        Multislot         []adslot30 `json:"multislot"`
        App               app        `json:"app"`
        Device            device     `json:"device"`
        Network           network    `json:"network,omitempty"`
        Regs              regs       `json:"regs,omitempty"`
        Geo               geo        `json:"geo,omitempty"`
        Consent           string     `json:"consent,omitempty"`
        ClientAdRequestId string     `json:"clientAdRequestId,omitempty"`
}

type adslot30 struct {
        Slotid                   string   `json:"slotid"`
        Adtype                   int32    `json:"adtype"`
        Test                     int32    `json:"test"`
        TotalDuration            int32    `json:"totalDuration,omitempty"`
        Orientation              int32    `json:"orientation,omitempty"`
        W                        int64    `json:"w,omitempty"`
        H                        int64    `json:"h,omitempty"`
        Format                   []format `json:"format,omitempty"`
        DetailedCreativeTypeList []string `json:"detailedCreativeTypeList,omitempty"`
}

type format struct {
        W int64 `json:"w,omitempty"`
        H int64 `json:"h,omitempty"`
}

type app struct {
        Version string `json:"version,omitempty"`
        Name    string `json:"name,omitempty"`
        Pkgname string `json:"pkgname"`
        Lang    string `json:"lang,omitempty"`
        Country string `json:"country,omitempty"`
}

type device struct {
        Type                int32   `json:"type,omitempty"`
        Useragent           string  `json:"useragent,omitempty"`
        Os                  string  `json:"os,omitempty"`
        Version             string  `json:"version,omitempty"`
        Maker               string  `json:"maker,omitempty"`
        Model               string  `json:"model,omitempty"`
        Width               int32   `json:"width,omitempty"`
        Height              int32   `json:"height,omitempty"`
        Language            string  `json:"language,omitempty"`
        BuildVersion        string  `json:"buildVersion,omitempty"`
        Dpi                 int32   `json:"dpi,omitempty"`
        Pxratio             float32 `json:"pxratio,omitempty"`
        Imei                string  `json:"imei,omitempty"`
        Oaid                string  `json:"oaid,omitempty"`
        IsTrackingEnabled   string  `json:"isTrackingEnabled,omitempty"`
        EmuiVer             string  `json:"emuiVer,omitempty"`
        LocaleCountry       string  `json:"localeCountry"`
        BelongCountry       string  `json:"belongCountry"`
        GaidTrackingEnabled string  `json:"gaidTrackingEnabled,omitempty"`
        Gaid                string  `json:"gaid,omitempty"`
        ClientTime          string  `json:"clientTime"`
        Ip                  string  `json:"ip,omitempty"`
}

type network struct {
        Type     int32      `json:"type"`
        Carrier  int32      `json:"carrier,omitempty"`
        CellInfo []cellInfo `json:"cellInfo,omitempty"`
}

type regs struct {
        Coppa int32 `json:"coppa,omitempty"`
}

type geo struct {
        Lon      float32 `json:"lon,omitempty"`
        Lat      float32 `json:"lat,omitempty"`
        Accuracy int32   `json:"accuracy,omitempty"`
        Lastfix  int32   `json:"lastfix,omitempty"`
}

type cellInfo struct {
        Mcc string `json:"mcc,omitempty"`
        Mnc string `json:"mnc,omitempty"`
}

type huaweiAdsResponse struct {
        Retcode int32  `json:"retcode"`
        Reason  string `json:"reason"`
        Multiad []ad30 `json:"multiad"`
}

type ad30 struct {
        AdType    int32     `json:"adtype"`
        Slotid    string    `json:"slotid"`
        Retcode30 int32     `json:"retcode30"`
        Content   []content `json:"content"`
}

type content struct {
        Contentid       string    `json:"contentid"`
        Interactiontype int32     `json:"interactiontype"`
        Creativetype    int32     `json:"creativetype"`
        MetaData        metaData  `json:"metaData"`
        Monitor         []monitor `json:"monitor"`
        Cur             string    `json:"cur"`
        Price           float64   `json:"price"`
}

type metaData struct {
        Title       string      `json:"title"`
        Description string      `json:"description"`
        ImageInfo   []imageInfo `json:"imageInfo"`
        Icon        []icon      `json:"icon"`
        ClickUrl    string      `json:"clickUrl"`
        Intent      string      `json:"intent"`
        VideoInfo   videoInfo   `json:"videoInfo"`
        ApkInfo     apkInfo     `json:"apkInfo"`
        Duration    int64       `json:"duration"`
        MediaFile   mediaFile   `json:"mediaFile"`
        Cta         string      `json:"cta"`
}

type imageInfo struct {
        Url       string `json:"url"`
        Height    int64  `json:"height"`
        FileSize  int64  `json:"fileSize"`
        Sha256    string `json:"sha256"`
        ImageType string `json:"imageType"`
        Width     int64  `json:"width"`
}

type icon struct {
        Url       string `json:"url"`
        Height    int64  `json:"height"`
        FileSize  int64  `json:"fileSize"`
        Sha256    string `json:"sha256"`
        ImageType string `json:"imageType"`
        Width     int64  `json:"width"`
}

type videoInfo struct {
        VideoDownloadUrl string  `json:"videoDownloadUrl"`
        VideoDuration    int32   `json:"videoDuration"`
        VideoFileSize    int32   `json:"videoFileSize"`
        Sha256           string  `json:"sha256"`
        VideoRatio       float32 `json:"videoRatio"`
        Width            int32   `json:"width"`
        Height           int32   `json:"height"`
}

type apkInfo struct {
        Url         string `json:"url"`
        FileSize    int64  `json:"fileSize"`
        Sha256      string `json:"sha256"`
        PackageName string `json:"packageName"`
        SecondUrl   string `json:"secondUrl"`
        AppName     string `json:"appName"`
        VersionName string `json:"versionName"`
        AppDesc     string `json:"appDesc"`
        AppIcon     string `json:"appIcon"`
}

type mediaFile struct {
        Mime     string `json:"mime"`
        Width    int64  `json:"width"`
        Height   int64  `json:"height"`
        FileSize int64  `json:"fileSize"`
        Url      string `json:"url"`
        Sha256   string `json:"sha256"`
}

type monitor struct {
        EventType string   `json:"eventType"`
        Url       []string `json:"url"`
}

type adapter struct {
        endpoint  string
        extraInfo ExtraInfo
}

type ExtraInfo struct {
        PkgNameConvert              []pkgNameConvert `json:"pkgNameConvert,omitempty"`
        CloseSiteSelectionByCountry string           `json:"closeSiteSelectionByCountry,omitempty"`
}

type pkgNameConvert struct {
        ConvertedPkgName           string   `json:"convertedPkgName,omitempty"`
        UnconvertedPkgNames        []string `json:"unconvertedPkgNames,omitempty"`
        UnconvertedPkgNameKeyWords []string `json:"unconvertedPkgNameKeyWords,omitempty"`
        UnconvertedPkgNamePrefixs  []string `json:"unconvertedPkgNamePrefixs,omitempty"`
        ExceptionPkgNames          []string `json:"exceptionPkgNames,omitempty"`
}

type empty struct {
}

func (a *adapter) MakeRequests(openRTBRequest *openrtb2.BidRequest,
        reqInfo *adapters.ExtraRequestInfo) (requestsToBidder []*adapters.RequestData, errs []error) <span class="cov8" title="1">{
        // the upstream code already confirms that there is a non-zero number of impressions
        numRequests := len(openRTBRequest.Imp)
        var request huaweiAdsRequest
        var header http.Header
        var multislot = make([]adslot30, 0, numRequests)

        var huaweiAdsImpExt *openrtb_ext.ExtImpHuaweiAds
        for index := 0; index &lt; numRequests; index++ </span><span class="cov8" title="1">{
                var err1 error
                huaweiAdsImpExt, err1 = unmarshalExtImpHuaweiAds(&amp;openRTBRequest.Imp[index])
                if err1 != nil </span><span class="cov8" title="1">{
                        return nil, []error{err1}
                }</span>

                <span class="cov8" title="1">if huaweiAdsImpExt == nil </span><span class="cov0" title="0">{
                        return nil, []error{errors.New("Unmarshal ExtImpHuaweiAds failed: huaweiAdsImpExt is nil.")}
                }</span>

                <span class="cov8" title="1">adslot30, err := getReqAdslot30(huaweiAdsImpExt, &amp;openRTBRequest.Imp[index])
                if err != nil </span><span class="cov8" title="1">{
                        return nil, []error{err}
                }</span>

                <span class="cov8" title="1">multislot = append(multislot, adslot30)</span>
        }
        <span class="cov8" title="1">request.Multislot = multislot
        request.ClientAdRequestId = openRTBRequest.ID

        countryCode, err := getReqJson(&amp;request, openRTBRequest, a.extraInfo)
        if err != nil </span><span class="cov8" title="1">{
                return nil, []error{err}
        }</span>

        <span class="cov8" title="1">reqJSON, err := json.Marshal(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []error{err}
        }</span>

        //        our request header's Authorization is changing by time, cannot verify by a certain string,
        //        use isTestAuthorization = true only when run testcase
        <span class="cov8" title="1">var isTestAuthorization = false
        if huaweiAdsImpExt != nil &amp;&amp; huaweiAdsImpExt.IsTestAuthorization == "true" </span><span class="cov8" title="1">{
                isTestAuthorization = true
        }</span>
        <span class="cov8" title="1">header = getHeaders(huaweiAdsImpExt, openRTBRequest, isTestAuthorization)
        bidRequest := &amp;adapters.RequestData{
                Method:  http.MethodPost,
                Uri:     getFinalEndPoint(countryCode, a.endpoint, a.extraInfo),
                Body:    reqJSON,
                Headers: header,
        }

        return []*adapters.RequestData{bidRequest}, nil</span>
}

// countryCode is alpha2, choose the corresponding site end point
func getFinalEndPoint(countryCode string, defaultEndpoint string, extraInfo ExtraInfo) string <span class="cov8" title="1">{
        // closeSiteSelectionByCountry == 1, close site selection, use the defaultEndpoint
        if "1" == extraInfo.CloseSiteSelectionByCountry </span><span class="cov0" title="0">{
                return defaultEndpoint
        }</span>

        <span class="cov8" title="1">if countryCode == "" || len(countryCode) &gt; 2 </span><span class="cov0" title="0">{
                return defaultEndpoint
        }</span>
        <span class="cov8" title="1">var europeanSiteCountryCodeGroup = map[string]empty{"AX": {}, "AL": {}, "AD": {}, "AU": {}, "AT": {}, "BE": {},
                "BA": {}, "BG": {}, "CA": {}, "HR": {}, "CY": {}, "CZ": {}, "DK": {}, "EE": {}, "FO": {}, "FI": {},
                "FR": {}, "DE": {}, "GI": {}, "GR": {}, "GL": {}, "GG": {}, "VA": {}, "HU": {}, "IS": {}, "IE": {},
                "IM": {}, "IL": {}, "IT": {}, "JE": {}, "YK": {}, "LV": {}, "LI": {}, "LT": {}, "LU": {}, "MT": {},
                "MD": {}, "MC": {}, "ME": {}, "NL": {}, "AN": {}, "NZ": {}, "NO": {}, "PL": {}, "PT": {}, "RO": {},
                "MF": {}, "VC": {}, "SM": {}, "RS": {}, "SX": {}, "SK": {}, "SI": {}, "ES": {}, "SE": {}, "CH": {},
                "TR": {}, "UA": {}, "GB": {}, "US": {}, "MK": {}, "SJ": {}, "BQ": {}, "PM": {}, "CW": {}}
        var russianSiteCountryCodeGroup = map[string]empty{"RU": {}}
        var chineseSiteCountryCodeGroup = map[string]empty{"CN": {}}
        // choose site
        if _, exists := chineseSiteCountryCodeGroup[countryCode]; exists </span><span class="cov8" title="1">{
                return chineseSiteEndPoint
        }</span> else<span class="cov8" title="1"> if _, exists := russianSiteCountryCodeGroup[countryCode]; exists </span><span class="cov8" title="1">{
                return russianSiteEndPoint
        }</span> else<span class="cov8" title="1"> if _, exists := europeanSiteCountryCodeGroup[countryCode]; exists </span><span class="cov8" title="1">{
                return europeanSiteEndPoint
        }</span> else<span class="cov8" title="1"> {
                return asianSiteEndPoint
        }</span>
}

func (a *adapter) MakeBids(openRTBRequest *openrtb2.BidRequest, requestToBidder *adapters.RequestData,
        bidderRawResponse *adapters.ResponseData) (bidderResponse *adapters.BidderResponse, errs []error) <span class="cov8" title="1">{
        httpStatusError := checkRespStatusCode(bidderRawResponse)
        if httpStatusError != nil </span><span class="cov8" title="1">{
                return nil, []error{httpStatusError}
        }</span>

        <span class="cov8" title="1">var huaweiAdsResponse huaweiAdsResponse
        if err := json.Unmarshal(bidderRawResponse.Body, &amp;huaweiAdsResponse); err != nil </span><span class="cov0" title="0">{
                return nil, []error{&amp;errortypes.BadServerResponse{
                        Message: "Unable to parse server response",
                }}
        }</span>

        <span class="cov8" title="1">if err := checkHuaweiAdsResponseRetcode(huaweiAdsResponse); err != nil </span><span class="cov8" title="1">{
                return nil, []error{err}
        }</span>

        <span class="cov8" title="1">bidderResponse, err := a.convertHuaweiAdsRespToBidderResp(&amp;huaweiAdsResponse, openRTBRequest)
        if err != nil </span><span class="cov8" title="1">{
                return nil, []error{err}
        }</span>

        <span class="cov8" title="1">return bidderResponse, nil</span>
}

// Builder builds a new instance of the HuaweiAds adapter for the given bidder with the given config.
func Builder(bidderName openrtb_ext.BidderName, config config.Adapter, server config.Server) (adapters.Bidder, error) <span class="cov8" title="1">{
        extraInfo, err := getExtraInfo(config.ExtraAdapterInfo)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">bidder := &amp;adapter{
                endpoint:  config.Endpoint,
                extraInfo: extraInfo,
        }
        return bidder, nil</span>
}

func getExtraInfo(v string) (ExtraInfo, error) <span class="cov8" title="1">{
        var extraInfo ExtraInfo
        if len(v) == 0 </span><span class="cov8" title="1">{
                return extraInfo, nil
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal([]byte(v), &amp;extraInfo); err != nil </span><span class="cov0" title="0">{
                return extraInfo, fmt.Errorf("invalid extra info: %v , pls check", err)
        }</span>

        <span class="cov8" title="1">for _, convert := range extraInfo.PkgNameConvert </span><span class="cov8" title="1">{
                if convert.ConvertedPkgName == "" </span><span class="cov8" title="1">{
                        return extraInfo, fmt.Errorf("invalid extra info: ConvertedPkgName is empty, pls check")
                }</span>

                <span class="cov8" title="1">if convert.UnconvertedPkgNameKeyWords != nil </span><span class="cov8" title="1">{
                        for _, keyword := range convert.UnconvertedPkgNameKeyWords </span><span class="cov8" title="1">{
                                if keyword == "" </span><span class="cov8" title="1">{
                                        return extraInfo, fmt.Errorf("invalid extra info: UnconvertedPkgNameKeyWords has a empty keyword, pls check")
                                }</span>
                        }
                }

                <span class="cov8" title="1">if convert.UnconvertedPkgNamePrefixs != nil </span><span class="cov8" title="1">{
                        for _, prefix := range convert.UnconvertedPkgNamePrefixs </span><span class="cov8" title="1">{
                                if prefix == "" </span><span class="cov8" title="1">{
                                        return extraInfo, fmt.Errorf("invalid extra info: UnconvertedPkgNamePrefixs has a empty value, pls check")
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return extraInfo, nil</span>
}

// getHeaders: get request header, Authorization -&gt; digest
func getHeaders(huaweiAdsImpExt *openrtb_ext.ExtImpHuaweiAds, request *openrtb2.BidRequest, isTestAuthorization bool) http.Header <span class="cov8" title="1">{
        headers := http.Header{}
        headers.Add("Content-Type", "application/json;charset=utf-8")
        headers.Add("Accept", "application/json")
        if huaweiAdsImpExt == nil </span><span class="cov0" title="0">{
                return headers
        }</span>
        <span class="cov8" title="1">headers.Add("Authorization", getDigestAuthorization(huaweiAdsImpExt, isTestAuthorization))

        if request.Device != nil &amp;&amp; len(request.Device.UA) &gt; 0 </span><span class="cov8" title="1">{
                headers.Add("User-Agent", request.Device.UA)
        }</span>
        <span class="cov8" title="1">return headers</span>
}

// getReqJson: get body json for HuaweiAds request
func getReqJson(request *huaweiAdsRequest, openRTBRequest *openrtb2.BidRequest, extraInfo ExtraInfo) (countryCode string, err error) <span class="cov8" title="1">{
        request.Version = huaweiAdxApiVersion
        if countryCode, err = getReqAppInfo(request, openRTBRequest, extraInfo); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if err = getReqDeviceInfo(request, openRTBRequest); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">getReqNetWorkInfo(request, openRTBRequest)
        getReqRegsInfo(request, openRTBRequest)
        getReqGeoInfo(request, openRTBRequest)
        getReqConsentInfo(request, openRTBRequest)
        return countryCode, nil</span>
}

func getReqAdslot30(huaweiAdsImpExt *openrtb_ext.ExtImpHuaweiAds,
        openRTBImp *openrtb2.Imp) (adslot30, error) <span class="cov8" title="1">{
        adtype := convertAdtypeStringToInteger(strings.ToLower(huaweiAdsImpExt.Adtype))
        testStatus := 0
        if huaweiAdsImpExt.IsTestAuthorization == "true" </span><span class="cov8" title="1">{
                testStatus = 1
        }</span>
        <span class="cov8" title="1">var adslot30 = adslot30{
                Slotid: huaweiAdsImpExt.SlotId,
                Adtype: adtype,
                Test:   int32(testStatus),
        }
        if err := checkAndExtractOpenrtbFormat(&amp;adslot30, adtype, huaweiAdsImpExt.Adtype, openRTBImp); err != nil </span><span class="cov8" title="1">{
                return adslot30, err
        }</span>
        <span class="cov8" title="1">return adslot30, nil</span>
}

// opentrb :  huawei adtype
// banner &lt;-&gt; banner, interstitial
// native &lt;-&gt; native
// video  &lt;-&gt;  banner, roll, interstitial, rewarded
func checkAndExtractOpenrtbFormat(adslot30 *adslot30, adtype int32, yourAdtype string, openRTBImp *openrtb2.Imp) error <span class="cov8" title="1">{
        if openRTBImp.Banner != nil </span><span class="cov8" title="1">{
                if adtype != banner &amp;&amp; adtype != interstitial </span><span class="cov8" title="1">{
                        return errors.New("check openrtb format: request has banner, doesn't correspond to huawei adtype " + yourAdtype)
                }</span>
                <span class="cov8" title="1">getBannerFormat(adslot30, openRTBImp)</span>
        } else<span class="cov8" title="1"> if openRTBImp.Native != nil </span><span class="cov8" title="1">{
                if adtype != native </span><span class="cov8" title="1">{
                        return errors.New("check openrtb format: request has native, doesn't correspond to huawei adtype " + yourAdtype)
                }</span>
                <span class="cov8" title="1">if err := getNativeFormat(adslot30, openRTBImp); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if openRTBImp.Video != nil </span><span class="cov8" title="1">{
                if adtype != banner &amp;&amp; adtype != interstitial &amp;&amp; adtype != rewarded &amp;&amp; adtype != roll </span><span class="cov8" title="1">{
                        return errors.New("check openrtb format: request has video, doesn't correspond to huawei adtype " + yourAdtype)
                }</span>
                <span class="cov8" title="1">if err := getVideoFormat(adslot30, adtype, openRTBImp); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if openRTBImp.Audio != nil </span><span class="cov8" title="1">{
                return errors.New("check openrtb format: request has audio, not currently supported")
        }</span> else<span class="cov8" title="1"> {
                return errors.New("check openrtb format: please choose one of our supported type banner, native, or video")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getBannerFormat(adslot30 *adslot30, openRTBImp *openrtb2.Imp) <span class="cov8" title="1">{
        if openRTBImp.Banner.W != nil &amp;&amp; openRTBImp.Banner.H != nil </span><span class="cov8" title="1">{
                adslot30.W = *openRTBImp.Banner.W
                adslot30.H = *openRTBImp.Banner.H
        }</span>
        <span class="cov8" title="1">if len(openRTBImp.Banner.Format) != 0 </span><span class="cov8" title="1">{
                var formats = make([]format, 0, len(openRTBImp.Banner.Format))
                for _, f := range openRTBImp.Banner.Format </span><span class="cov8" title="1">{
                        if f.H != 0 &amp;&amp; f.W != 0 </span><span class="cov8" title="1">{
                                formats = append(formats, format{f.W, f.H})
                        }</span>
                }
                <span class="cov8" title="1">adslot30.Format = formats</span>
        }
}

func getNativeFormat(adslot30 *adslot30, openRTBImp *openrtb2.Imp) error <span class="cov8" title="1">{
        if openRTBImp.Native.Request == "" </span><span class="cov8" title="1">{
                return errors.New("extract openrtb native failed: imp.Native.Request is empty")
        }</span>

        <span class="cov8" title="1">var nativePayload nativeRequests.Request
        if err := json.Unmarshal(json.RawMessage(openRTBImp.Native.Request), &amp;nativePayload); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // only compute the main image number, type = native1.ImageAssetTypeMain
        <span class="cov8" title="1">var numMainImage = 0
        var numVideo = 0
        /* to fix low fill rate issue
        var width int64
        var height int64
        */
        for _, asset := range nativePayload.Assets </span><span class="cov8" title="1">{
                // Only one of the {title,img,video,data} objects should be present in each object.
                if asset.Video != nil </span><span class="cov8" title="1">{
                        numVideo++
                        continue</span>
                }
                // every image has the same W, H.
                <span class="cov8" title="1">if asset.Img != nil </span><span class="cov8" title="1">{
                        if asset.Img.Type == native1.ImageAssetTypeMain </span><span class="cov8" title="1">{
                                numMainImage++
                                /*if asset.Img.H != 0 &amp;&amp; asset.Img.W != 0 {
                                        width = asset.Img.W
                                        height = asset.Img.H
                                } else if asset.Img.WMin != 0 &amp;&amp; asset.Img.HMin != 0 {
                                        width = asset.Img.WMin
                                        height = asset.Img.HMin
                                }*/
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
        }
        /* to fix low fill rate issue
        adslot30.W = width
        adslot30.H = height */

        <span class="cov8" title="1">var detailedCreativeTypeList = make([]string, 0, 2)
        if numVideo &gt;= 1 </span><span class="cov8" title="1">{
                detailedCreativeTypeList = append(detailedCreativeTypeList, "903")
        }</span> else<span class="cov8" title="1"> if numMainImage &gt; 1 </span><span class="cov8" title="1">{
                detailedCreativeTypeList = append(detailedCreativeTypeList, "904")
        }</span> else<span class="cov8" title="1"> if numMainImage == 1 </span><span class="cov8" title="1">{
                detailedCreativeTypeList = append(detailedCreativeTypeList, "901")
        }</span> else<span class="cov0" title="0"> {
                detailedCreativeTypeList = append(detailedCreativeTypeList, "913", "914")
        }</span>
        <span class="cov8" title="1">adslot30.DetailedCreativeTypeList = detailedCreativeTypeList
        return nil</span>
}

// roll ad need TotalDuration
func getVideoFormat(adslot30 *adslot30, adtype int32, openRTBImp *openrtb2.Imp) error <span class="cov8" title="1">{
        adslot30.W = openRTBImp.Video.W
        adslot30.H = openRTBImp.Video.H

        if adtype == roll </span><span class="cov8" title="1">{
                if openRTBImp.Video.MaxDuration == 0 </span><span class="cov8" title="1">{
                        return errors.New("extract openrtb video failed: MaxDuration is empty when huaweiads adtype is roll.")
                }</span>
                <span class="cov8" title="1">adslot30.TotalDuration = int32(openRTBImp.Video.MaxDuration)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func convertAdtypeStringToInteger(adtypeLower string) int32 <span class="cov8" title="1">{
        switch adtypeLower </span>{
        case "banner":<span class="cov8" title="1">
                return banner</span>
        case "native":<span class="cov8" title="1">
                return native</span>
        case "rewarded":<span class="cov8" title="1">
                return rewarded</span>
        case "interstitial":<span class="cov8" title="1">
                return interstitial</span>
        case "roll":<span class="cov8" title="1">
                return roll</span>
        case "splash":<span class="cov0" title="0">
                return splash</span>
        case "magazinelock":<span class="cov0" title="0">
                return magazinelock</span>
        case "audio":<span class="cov0" title="0">
                return audio</span>
        default:<span class="cov0" title="0">
                return banner</span>
        }
}

// getReqAppInfo: get app information for HuaweiAds request
func getReqAppInfo(request *huaweiAdsRequest, openRTBRequest *openrtb2.BidRequest, extraInfo ExtraInfo) (countryCode string, err error) <span class="cov8" title="1">{
        var app app
        if openRTBRequest.App != nil </span><span class="cov8" title="1">{
                if openRTBRequest.App.Ver != "" </span><span class="cov8" title="1">{
                        app.Version = openRTBRequest.App.Ver
                }</span>
                <span class="cov8" title="1">if openRTBRequest.App.Name != "" </span><span class="cov8" title="1">{
                        app.Name = openRTBRequest.App.Name
                }</span>

                // bundle cannot be empty, we need package name.
                <span class="cov8" title="1">if openRTBRequest.App.Bundle != "" </span><span class="cov8" title="1">{
                        app.Pkgname = getFinalPkgName(openRTBRequest.App.Bundle, extraInfo)
                }</span> else<span class="cov0" title="0"> {
                        return "", errors.New("generate HuaweiAds AppInfo failed: openrtb BidRequest.App.Bundle is empty.")
                }</span>

                <span class="cov8" title="1">if openRTBRequest.App.Content != nil &amp;&amp; openRTBRequest.App.Content.Language != "" </span><span class="cov8" title="1">{
                        app.Lang = openRTBRequest.App.Content.Language
                }</span> else<span class="cov8" title="1"> {
                        app.Lang = "en"
                }</span>
        }
        <span class="cov8" title="1">countryCode = getCountryCode(openRTBRequest)
        app.Country = countryCode
        request.App = app
        return countryCode, nil</span>
}

// when it has pkgNameConvert (include different rules)
// 1. when bundleName in ExceptionPkgNames, finalPkgname = bundleName
// 2. when bundleName conform UnconvertedPkgNames, finalPkgname = ConvertedPkgName
// 3. when bundleName conform keyword, finalPkgname = ConvertedPkgName
// 4. when bundleName conform prefix, finalPkgname = ConvertedPkgName
func getFinalPkgName(bundleName string, extraInfo ExtraInfo) string <span class="cov8" title="1">{
        for _, convert := range extraInfo.PkgNameConvert </span><span class="cov8" title="1">{
                if convert.ConvertedPkgName == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, name := range convert.ExceptionPkgNames </span><span class="cov8" title="1">{
                        if name == bundleName </span><span class="cov8" title="1">{
                                return bundleName
                        }</span>
                }

                <span class="cov8" title="1">for _, name := range convert.UnconvertedPkgNames </span><span class="cov8" title="1">{
                        if name == bundleName || name == "*" </span><span class="cov8" title="1">{
                                return convert.ConvertedPkgName
                        }</span>
                }

                <span class="cov8" title="1">for _, keyword := range convert.UnconvertedPkgNameKeyWords </span><span class="cov8" title="1">{
                        if strings.Index(bundleName, keyword) &gt; 0 </span><span class="cov8" title="1">{
                                return convert.ConvertedPkgName
                        }</span>
                }

                <span class="cov8" title="1">for _, prefix := range convert.UnconvertedPkgNamePrefixs </span><span class="cov8" title="1">{
                        if strings.HasPrefix(bundleName, prefix) </span><span class="cov8" title="1">{
                                return convert.ConvertedPkgName
                        }</span>
                }
        }
        <span class="cov8" title="1">return bundleName</span>
}

// getClientTime: get field clientTime, format: 2006-01-02 15:04:05.000+0200
// If this parameter is not passed, the server time is used
func getClientTime(clientTime string) (newClientTime string) <span class="cov8" title="1">{
        var zone = defaultTimeZone
        t := time.Now().Local().Format(time.RFC822Z)
        index := strings.IndexAny(t, "-+")
        if index &gt; 0 &amp;&amp; len(t)-index == 5 </span><span class="cov8" title="1">{
                zone = t[index:]
        }</span>
        <span class="cov8" title="1">if clientTime == "" </span><span class="cov8" title="1">{
                return time.Now().Format(timeFormat) + zone
        }</span>
        <span class="cov8" title="1">if isMatched, _ := regexp.MatchString("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}[+-]{1}\\d{4}$", clientTime); isMatched </span><span class="cov8" title="1">{
                return clientTime
        }</span>
        <span class="cov0" title="0">if isMatched, _ := regexp.MatchString("^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}$", clientTime); isMatched </span><span class="cov0" title="0">{
                return clientTime + zone
        }</span>
        <span class="cov0" title="0">return time.Now().Format(timeFormat) + zone</span>
}

// getReqDeviceInfo: get device information for HuaweiAds request
func getReqDeviceInfo(request *huaweiAdsRequest, openRTBRequest *openrtb2.BidRequest) (err error) <span class="cov8" title="1">{
        var device device
        if openRTBRequest.Device != nil </span><span class="cov8" title="1">{
                device.Type = int32(openRTBRequest.Device.DeviceType)
                device.Useragent = openRTBRequest.Device.UA
                device.Os = openRTBRequest.Device.OS
                device.Version = openRTBRequest.Device.OSV
                device.Maker = openRTBRequest.Device.Make
                device.Model = openRTBRequest.Device.Model
                if device.Model == "" </span><span class="cov0" title="0">{
                        device.Model = defaultModelName
                }</span>
                <span class="cov8" title="1">device.Height = int32(openRTBRequest.Device.H)
                device.Width = int32(openRTBRequest.Device.W)
                device.Language = openRTBRequest.Device.Language
                device.Pxratio = float32(openRTBRequest.Device.PxRatio)
                var country = getCountryCode(openRTBRequest)
                device.BelongCountry = country
                device.LocaleCountry = country
                device.Ip = openRTBRequest.Device.IP
                device.Gaid = openRTBRequest.Device.IFA
                device.ClientTime = getClientTime("")</span>
        }

        // get oaid gaid imei in openRTBRequest.User.Ext.Data
        <span class="cov8" title="1">if err = getDeviceIDFromUserExt(&amp;device, openRTBRequest); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // IsTrackingEnabled = 1 - DNT
        <span class="cov8" title="1">if openRTBRequest.Device != nil &amp;&amp; openRTBRequest.Device.DNT != nil </span><span class="cov8" title="1">{
                if device.Oaid != "" </span><span class="cov8" title="1">{
                        device.IsTrackingEnabled = strconv.Itoa(1 - int(*openRTBRequest.Device.DNT))
                }</span>
                <span class="cov8" title="1">if device.Gaid != "" </span><span class="cov8" title="1">{
                        device.GaidTrackingEnabled = strconv.Itoa(1 - int(*openRTBRequest.Device.DNT))
                }</span>
        }

        <span class="cov8" title="1">request.Device = device
        return nil</span>
}

func getCountryCode(openRTBRequest *openrtb2.BidRequest) string <span class="cov8" title="1">{
        if openRTBRequest.Device != nil &amp;&amp; openRTBRequest.Device.Geo != nil &amp;&amp; openRTBRequest.Device.Geo.Country != "" </span><span class="cov8" title="1">{
                return convertCountryCode(openRTBRequest.Device.Geo.Country)
        }</span> else<span class="cov8" title="1"> if openRTBRequest.User != nil &amp;&amp; openRTBRequest.User.Geo != nil &amp;&amp; openRTBRequest.User.Geo.Country != "" </span><span class="cov8" title="1">{
                return convertCountryCode(openRTBRequest.User.Geo.Country)
        }</span> else<span class="cov8" title="1"> if openRTBRequest.Device != nil &amp;&amp; openRTBRequest.Device.MCCMNC != "" </span><span class="cov8" title="1">{
                return getCountryCodeFromMCC(openRTBRequest.Device.MCCMNC)
        }</span> else<span class="cov8" title="1"> {
                return defaultCountryName
        }</span>
}

// convertCountryCode: ISO 3166-1 Alpha3 -&gt; Alpha2, Some countries may use
func convertCountryCode(country string) (out string) <span class="cov8" title="1">{
        if country == "" </span><span class="cov0" title="0">{
                return defaultCountryName
        }</span>
        <span class="cov8" title="1">var mapCountryCodeAlpha3ToAlpha2 = map[string]string{"AND": "AD", "AGO": "AO", "AUT": "AT", "BGD": "BD",
                "BLR": "BY", "CAF": "CF", "TCD": "TD", "CHL": "CL", "CHN": "CN", "COG": "CG", "COD": "CD", "DNK": "DK",
                "GNQ": "GQ", "EST": "EE", "GIN": "GN", "GNB": "GW", "GUY": "GY", "IRQ": "IQ", "IRL": "IE", "ISR": "IL",
                "KAZ": "KZ", "LBY": "LY", "MDG": "MG", "MDV": "MV", "MEX": "MX", "MNE": "ME", "MOZ": "MZ", "PAK": "PK",
                "PNG": "PG", "PRY": "PY", "POL": "PL", "PRT": "PT", "SRB": "RS", "SVK": "SK", "SVN": "SI", "SWE": "SE",
                "TUN": "TN", "TUR": "TR", "TKM": "TM", "UKR": "UA", "ARE": "AE", "URY": "UY"}
        if mappedCountry, exists := mapCountryCodeAlpha3ToAlpha2[country]; exists </span><span class="cov8" title="1">{
                return mappedCountry
        }</span>

        <span class="cov8" title="1">if len(country) &gt;= 2 </span><span class="cov8" title="1">{
                return country[0:2]
        }</span>

        <span class="cov0" title="0">return defaultCountryName</span>
}

func getCountryCodeFromMCC(MCC string) (out string) <span class="cov8" title="1">{
        var countryMCC = strings.Split(MCC, "-")[0]
        intVar, err := strconv.Atoi(countryMCC)

        if err != nil </span><span class="cov8" title="1">{
                return defaultCountryName
        }</span> else<span class="cov8" title="1"> {
                if result, found := MccList[intVar]; found </span><span class="cov8" title="1">{
                        return strings.ToUpper(result)
                }</span> else<span class="cov8" title="1"> {
                        return defaultCountryName
                }</span>
        }
}

// getDeviceID include oaid gaid imei. In prebid mobile, use TargetingParams.addUserData("imei", "imei-test");
// When ifa: gaid exists, other device id can be passed by TargetingParams.addUserData("oaid", "oaid-test");
func getDeviceIDFromUserExt(device *device, openRTBRequest *openrtb2.BidRequest) (err error) <span class="cov8" title="1">{
        var userObjExist = true
        if openRTBRequest.User == nil || openRTBRequest.User.Ext == nil </span><span class="cov8" title="1">{
                userObjExist = false
        }</span>
        <span class="cov8" title="1">if userObjExist </span><span class="cov8" title="1">{
                var extUserDataHuaweiAds openrtb_ext.ExtUserDataHuaweiAds
                if err := json.Unmarshal(openRTBRequest.User.Ext, &amp;extUserDataHuaweiAds); err != nil </span><span class="cov8" title="1">{
                        return errors.New("get gaid from openrtb Device.IFA failed, and get device id failed: Unmarshal openRTBRequest.User.Ext -&gt; extUserDataHuaweiAds. Error: " + err.Error())
                }</span>

                <span class="cov8" title="1">var deviceId = extUserDataHuaweiAds.Data
                isValidDeviceId := false

                if len(deviceId.Oaid) &gt; 0 </span><span class="cov8" title="1">{
                        device.Oaid = deviceId.Oaid[0]
                        isValidDeviceId = true
                }</span>
                <span class="cov8" title="1">if len(deviceId.Gaid) &gt; 0 </span><span class="cov8" title="1">{
                        device.Gaid = deviceId.Gaid[0]
                        isValidDeviceId = true
                }</span>
                <span class="cov8" title="1">if len(device.Gaid) &gt; 0 </span><span class="cov8" title="1">{
                        isValidDeviceId = true
                }</span>
                <span class="cov8" title="1">if len(deviceId.Imei) &gt; 0 </span><span class="cov8" title="1">{
                        device.Imei = deviceId.Imei[0]
                        isValidDeviceId = true
                }</span>

                <span class="cov8" title="1">if !isValidDeviceId </span><span class="cov8" title="1">{
                        return errors.New("getDeviceID: Imei ,Oaid, Gaid are all empty.")
                }</span>
                <span class="cov8" title="1">if len(deviceId.ClientTime) &gt; 0 </span><span class="cov8" title="1">{
                        device.ClientTime = getClientTime(deviceId.ClientTime[0])
                }</span>
        } else<span class="cov8" title="1"> {
                if len(device.Gaid) == 0 </span><span class="cov8" title="1">{
                        return errors.New("getDeviceID: openRTBRequest.User.Ext is nil and device.Gaid is not specified.")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// getReqNetWorkInfo: for HuaweiAds request, include Carrier, Mcc, Mnc
func getReqNetWorkInfo(request *huaweiAdsRequest, openRTBRequest *openrtb2.BidRequest) <span class="cov8" title="1">{
        if openRTBRequest.Device != nil </span><span class="cov8" title="1">{
                var network network
                if openRTBRequest.Device.ConnectionType != nil </span><span class="cov8" title="1">{
                        network.Type = int32(*openRTBRequest.Device.ConnectionType)
                }</span> else<span class="cov8" title="1"> {
                        network.Type = defaultUnknownNetworkType
                }</span>

                <span class="cov8" title="1">var cellInfos []cellInfo
                if openRTBRequest.Device.MCCMNC != "" </span><span class="cov8" title="1">{
                        var arr = strings.Split(openRTBRequest.Device.MCCMNC, "-")
                        network.Carrier = 0
                        if len(arr) &gt;= 2 </span><span class="cov8" title="1">{
                                cellInfos = append(cellInfos, cellInfo{
                                        Mcc: arr[0],
                                        Mnc: arr[1],
                                })
                                var str = arr[0] + arr[1]
                                if str == "46000" || str == "46002" || str == "46007" </span><span class="cov0" title="0">{
                                        network.Carrier = 2
                                }</span> else<span class="cov8" title="1"> if str == "46001" || str == "46006" </span><span class="cov0" title="0">{
                                        network.Carrier = 1
                                }</span> else<span class="cov8" title="1"> if str == "46003" || str == "46005" || str == "46011" </span><span class="cov0" title="0">{
                                        network.Carrier = 3
                                }</span> else<span class="cov8" title="1"> {
                                        network.Carrier = 99
                                }</span>
                        }
                }
                <span class="cov8" title="1">network.CellInfo = cellInfos
                request.Network = network</span>
        }
}

// getReqRegsInfo: get regs information for HuaweiAds request, include Coppa
func getReqRegsInfo(request *huaweiAdsRequest, openRTBRequest *openrtb2.BidRequest) <span class="cov8" title="1">{
        if openRTBRequest.Regs != nil &amp;&amp; openRTBRequest.Regs.COPPA &gt;= 0 </span><span class="cov8" title="1">{
                var regs regs
                regs.Coppa = int32(openRTBRequest.Regs.COPPA)
                request.Regs = regs
        }</span>
}

// getReqGeoInfo: get geo information for HuaweiAds request, include Lon, Lat, Accuracy, Lastfix
func getReqGeoInfo(request *huaweiAdsRequest, openRTBRequest *openrtb2.BidRequest) <span class="cov8" title="1">{
        if openRTBRequest.Device != nil &amp;&amp; openRTBRequest.Device.Geo != nil </span><span class="cov8" title="1">{
                var geo geo
                geo.Lon = float32(openRTBRequest.Device.Geo.Lon)
                geo.Lat = float32(openRTBRequest.Device.Geo.Lat)
                geo.Accuracy = int32(openRTBRequest.Device.Geo.Accuracy)
                geo.Lastfix = int32(openRTBRequest.Device.Geo.LastFix)
                request.Geo = geo
        }</span>
}

// getReqGeoInfo: get GDPR consent
func getReqConsentInfo(request *huaweiAdsRequest, openRTBRequest *openrtb2.BidRequest) <span class="cov8" title="1">{
        if openRTBRequest.User != nil &amp;&amp; openRTBRequest.User.Ext != nil </span><span class="cov8" title="1">{
                var extUser openrtb_ext.ExtUser
                if err := json.Unmarshal(openRTBRequest.User.Ext, &amp;extUser); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">request.Consent = extUser.Consent</span>
        }
}

func unmarshalExtImpHuaweiAds(openRTBImp *openrtb2.Imp) (*openrtb_ext.ExtImpHuaweiAds, error) <span class="cov8" title="1">{
        var bidderExt adapters.ExtImpBidder
        var huaweiAdsImpExt openrtb_ext.ExtImpHuaweiAds
        if err := json.Unmarshal(openRTBImp.Ext, &amp;bidderExt); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Unmarshal: openRTBImp.Ext -&gt; bidderExt failed")
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(bidderExt.Bidder, &amp;huaweiAdsImpExt); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Unmarshal: bidderExt.Bidder -&gt; huaweiAdsImpExt failed")
        }</span>
        <span class="cov8" title="1">if huaweiAdsImpExt.SlotId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("ExtImpHuaweiAds: slotid is empty.")
        }</span>
        <span class="cov8" title="1">if huaweiAdsImpExt.Adtype == "" </span><span class="cov8" title="1">{
                return nil, errors.New("ExtImpHuaweiAds: adtype is empty.")
        }</span>
        <span class="cov8" title="1">if huaweiAdsImpExt.PublisherId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("ExtHuaweiAds: publisherid is empty.")
        }</span>
        <span class="cov8" title="1">if huaweiAdsImpExt.SignKey == "" </span><span class="cov8" title="1">{
                return nil, errors.New("ExtHuaweiAds: signkey is empty.")
        }</span>
        <span class="cov8" title="1">if huaweiAdsImpExt.KeyId == "" </span><span class="cov8" title="1">{
                return nil, errors.New("ExtImpHuaweiAds: keyid is empty.")
        }</span>
        <span class="cov8" title="1">return &amp;huaweiAdsImpExt, nil</span>
}

func checkRespStatusCode(response *adapters.ResponseData) error <span class="cov8" title="1">{
        if response.StatusCode == http.StatusNoContent </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if response.StatusCode == http.StatusServiceUnavailable </span><span class="cov8" title="1">{
                return &amp;errortypes.BadInput{
                        Message: fmt.Sprintf("Something went wrong, please contact your Account Manager. Status Code: [ %d ] ", response.StatusCode),
                }
        }</span>

        <span class="cov8" title="1">if response.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return &amp;errortypes.BadInput{
                        Message: fmt.Sprintf("Unexpected status code: [ %d ]. Run with request.debug = 1 for more info", response.StatusCode),
                }
        }</span>

        <span class="cov8" title="1">if response.Body == nil </span><span class="cov0" title="0">{
                return errors.New("bidderRawResponse body is empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func checkHuaweiAdsResponseRetcode(response huaweiAdsResponse) error <span class="cov8" title="1">{
        if response.Retcode == 200 || response.Retcode == 204 || response.Retcode == 206 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if (response.Retcode &lt; 600 &amp;&amp; response.Retcode &gt;= 400) || (response.Retcode &lt; 300 &amp;&amp; response.Retcode &gt; 200) </span><span class="cov8" title="1">{
                return &amp;errortypes.BadInput{
                        Message: fmt.Sprintf("HuaweiAdsResponse retcode: %d , reason: %s", response.Retcode, response.Reason),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// convertHuaweiAdsRespToBidderResp: convert HuaweiAds' response into bidder's response
func (a *adapter) convertHuaweiAdsRespToBidderResp(huaweiAdsResponse *huaweiAdsResponse, openRTBRequest *openrtb2.BidRequest) (bidderResponse *adapters.BidderResponse, err error) <span class="cov8" title="1">{
        if len(huaweiAdsResponse.Multiad) == 0 </span><span class="cov8" title="1">{
                return nil, errors.New("convert huaweiads response to bidder response failed: multiad length is 0, get no ads from huawei side.")
        }</span>
        <span class="cov8" title="1">bidderResponse = adapters.NewBidderResponseWithBidsCapacity(len(huaweiAdsResponse.Multiad))
        // Default Currency: CNY
        bidderResponse.Currency = "CNY"

        // record request Imp (slotid-&gt;imp, slotid-&gt;openrtb_ext.bidtype)
        mapSlotid2Imp := make(map[string]openrtb2.Imp, len(openRTBRequest.Imp))
        mapSlotid2MediaType := make(map[string]openrtb_ext.BidType, len(openRTBRequest.Imp))
        for _, imp := range openRTBRequest.Imp </span><span class="cov8" title="1">{
                huaweiAdsExt, err := unmarshalExtImpHuaweiAds(&amp;imp)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">mapSlotid2Imp[huaweiAdsExt.SlotId] = imp

                var mediaType = openrtb_ext.BidTypeBanner
                if imp.Video != nil </span><span class="cov8" title="1">{
                        mediaType = openrtb_ext.BidTypeVideo
                }</span> else<span class="cov8" title="1"> if imp.Native != nil </span><span class="cov8" title="1">{
                        mediaType = openrtb_ext.BidTypeNative
                }</span> else<span class="cov8" title="1"> if imp.Audio != nil </span><span class="cov0" title="0">{
                        mediaType = openrtb_ext.BidTypeAudio
                }</span>
                <span class="cov8" title="1">mapSlotid2MediaType[huaweiAdsExt.SlotId] = mediaType</span>
        }

        <span class="cov8" title="1">if len(mapSlotid2MediaType) &lt; 1 || len(mapSlotid2Imp) &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("convert huaweiads response to bidder response failed: openRTBRequest.imp is nil")
        }</span>

        <span class="cov8" title="1">for _, ad30 := range huaweiAdsResponse.Multiad </span><span class="cov8" title="1">{
                if mapSlotid2Imp[ad30.Slotid].ID == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if ad30.Retcode30 != 200 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, content := range ad30.Content </span><span class="cov8" title="1">{
                        var bid openrtb2.Bid
                        bid.ID = mapSlotid2Imp[ad30.Slotid].ID
                        bid.ImpID = mapSlotid2Imp[ad30.Slotid].ID
                        // The bidder has already helped us automatically convert the currency price, here only the CNY price is filled in
                        bid.Price = content.Price
                        bid.CrID = content.Contentid
                        // All currencies should be the same
                        if content.Cur != "" </span><span class="cov0" title="0">{
                                bidderResponse.Currency = content.Cur
                        }</span>

                        <span class="cov8" title="1">bid.AdM, bid.W, bid.H, err = a.handleHuaweiAdsContent(ad30.AdType, &amp;content, mapSlotid2MediaType[ad30.Slotid], mapSlotid2Imp[ad30.Slotid])
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">bid.ADomain = append(bid.ADomain, "huaweiads")
                        bid.NURL = getNurl(content)
                        bidderResponse.Bids = append(bidderResponse.Bids, &amp;adapters.TypedBid{
                                Bid:     &amp;bid,
                                BidType: mapSlotid2MediaType[ad30.Slotid],
                        })</span>
                }
        }
        <span class="cov8" title="1">return bidderResponse, nil</span>
}

func getNurl(content content) string <span class="cov8" title="1">{
        if len(content.Monitor) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, monitor := range content.Monitor </span><span class="cov8" title="1">{
                if monitor.EventType == "win" &amp;&amp; len(monitor.Url) != 0 </span><span class="cov0" title="0">{
                        return monitor.Url[0]
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// handleHuaweiAdsContent: get field Adm, Width, Height
func (a *adapter) handleHuaweiAdsContent(adType int32, content *content, bidType openrtb_ext.BidType, imp openrtb2.Imp) (
        adm string, adWidth int64, adHeight int64, err error) <span class="cov8" title="1">{
        switch bidType </span>{
        case openrtb_ext.BidTypeBanner:<span class="cov8" title="1">
                adm, adWidth, adHeight, err = a.extractAdmBanner(adType, content, bidType, imp)</span>
        case openrtb_ext.BidTypeNative:<span class="cov8" title="1">
                adm, adWidth, adHeight, err = a.extractAdmNative(adType, content, bidType, imp)</span>
        case openrtb_ext.BidTypeVideo:<span class="cov8" title="1">
                adm, adWidth, adHeight, err = a.extractAdmVideo(adType, content, bidType, imp)</span>
        default:<span class="cov0" title="0">
                return "", 0, 0, errors.New("no support bidtype: audio")</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", 0, 0, fmt.Errorf("generate Adm field from HuaweiAds response failed: %s", err)
        }</span>
        <span class="cov8" title="1">return adm, adWidth, adHeight, nil</span>
}

// extractAdmBanner: banner ad
func (a *adapter) extractAdmBanner(adType int32, content *content, bidType openrtb_ext.BidType, imp openrtb2.Imp) (adm string,
        adWidth int64, adHeight int64, err error) <span class="cov8" title="1">{
        // support openrtb: banner  &lt;=&gt; huawei adtype: banner, interstitial
        if adType != banner &amp;&amp; adType != interstitial </span><span class="cov8" title="1">{
                return "", 0, 0, errors.New("openrtb banner should correspond to huaweiads adtype: banner or interstitial")
        }</span>
        <span class="cov8" title="1">var creativeType = content.Creativetype
        if content.Creativetype &gt; 100 </span><span class="cov0" title="0">{
                creativeType = creativeType - 100
        }</span>
        <span class="cov8" title="1">if creativeType == text || creativeType == bigPicture || creativeType == bigPicture2 ||
                creativeType == smallPicture || creativeType == threeSmallPicturesText ||
                creativeType == iconText || creativeType == gif </span><span class="cov8" title="1">{
                return a.extractAdmPicture(content)
        }</span> else<span class="cov0" title="0"> if creativeType == videoText || creativeType == video || creativeType == videoWithPicturesText </span><span class="cov0" title="0">{
                return a.extractAdmVideo(adType, content, bidType, imp)
        }</span> else<span class="cov0" title="0"> {
                return "", 0, 0, errors.New("no banner support creativetype")
        }</span>
}

// extractAdmNative: native ad
func (a *adapter) extractAdmNative(adType int32, content *content, bidType openrtb_ext.BidType, openrtb2Imp openrtb2.Imp) (adm string,
        adWidth int64, adHeight int64, err error) <span class="cov8" title="1">{
        if adType != native </span><span class="cov8" title="1">{
                return "", 0, 0, errors.New("extract Adm for Native ad: huaweiads response is not a native ad")
        }</span>
        <span class="cov8" title="1">if openrtb2Imp.Native == nil </span><span class="cov0" title="0">{
                return "", 0, 0, errors.New("extract Adm for Native ad: imp.Native is nil")
        }</span>
        <span class="cov8" title="1">if openrtb2Imp.Native.Request == "" </span><span class="cov0" title="0">{
                return "", 0, 0, errors.New("extract Adm for Native ad: imp.Native.Request is empty")
        }</span>

        <span class="cov8" title="1">var nativePayload nativeRequests.Request
        if err := json.Unmarshal(json.RawMessage(openrtb2Imp.Native.Request), &amp;nativePayload); err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, err
        }</span>

        <span class="cov8" title="1">var nativeResult nativeResponse.Response
        var linkObject nativeResponse.Link
        linkObject.URL, err = a.getClickUrl(content)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, err
        }</span>

        <span class="cov8" title="1">nativeResult.Assets = make([]nativeResponse.Asset, 0, len(nativePayload.Assets))
        var imgIndex = 0
        var iconIndex = 0
        for _, asset := range nativePayload.Assets </span><span class="cov8" title="1">{
                var responseAsset nativeResponse.Asset
                if asset.Title != nil </span><span class="cov8" title="1">{
                        var titleObject nativeResponse.Title
                        titleObject.Text = getDecodeValue(content.MetaData.Title)
                        titleObject.Len = int64(len(titleObject.Text))
                        responseAsset.Title = &amp;titleObject
                }</span> else<span class="cov8" title="1"> if asset.Video != nil </span><span class="cov8" title="1">{
                        var videoObject nativeResponse.Video
                        var err error
                        if videoObject.VASTTag, adWidth, adHeight, err = a.extractAdmVideo(adType, content, bidType, openrtb2Imp); err != nil </span><span class="cov0" title="0">{
                                return "", 0, 0, err
                        }</span>
                        <span class="cov8" title="1">responseAsset.Video = &amp;videoObject</span>
                } else<span class="cov8" title="1"> if asset.Img != nil </span><span class="cov8" title="1">{
                        var imgObject nativeResponse.Image
                        imgObject.URL = ""
                        imgObject.Type = asset.Img.Type
                        if asset.Img.Type == native1.ImageAssetTypeIcon </span><span class="cov8" title="1">{
                                if len(content.MetaData.Icon) &gt; iconIndex </span><span class="cov8" title="1">{
                                        imgObject.URL = content.MetaData.Icon[iconIndex].Url
                                        imgObject.W = content.MetaData.Icon[iconIndex].Width
                                        imgObject.H = content.MetaData.Icon[iconIndex].Height
                                        iconIndex++
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if len(content.MetaData.ImageInfo) &gt; imgIndex </span><span class="cov8" title="1">{
                                        imgObject.URL = content.MetaData.ImageInfo[imgIndex].Url
                                        imgObject.W = content.MetaData.ImageInfo[imgIndex].Width
                                        imgObject.H = content.MetaData.ImageInfo[imgIndex].Height
                                        imgIndex++
                                }</span>
                        }
                        <span class="cov8" title="1">if adHeight == 0 &amp;&amp; adWidth == 0 </span><span class="cov8" title="1">{
                                adHeight = imgObject.H
                                adWidth = imgObject.W
                        }</span>
                        <span class="cov8" title="1">responseAsset.Img = &amp;imgObject</span>
                } else<span class="cov8" title="1"> if asset.Data != nil </span><span class="cov8" title="1">{
                        var dataObject nativeResponse.Data
                        dataObject.Label = ""
                        dataObject.Value = ""
                        if asset.Data.Type == native1.DataAssetTypeDesc || asset.Data.Type == native1.DataAssetTypeDesc2 </span><span class="cov8" title="1">{
                                dataObject.Label = "desc"
                                dataObject.Value = getDecodeValue(content.MetaData.Description)
                        }</span>
                        <span class="cov8" title="1">if asset.Data.Type == native1.DataAssetTypeCTAText </span><span class="cov0" title="0">{
                                dataObject.Value = getDecodeValue(content.MetaData.Cta)
                        }</span>
                        <span class="cov8" title="1">responseAsset.Data = &amp;dataObject</span>
                }
                <span class="cov8" title="1">var id = asset.ID
                responseAsset.ID = &amp;id
                nativeResult.Assets = append(nativeResult.Assets, responseAsset)</span>
        }

        // dsp imp click tracking + imp click tracking
        <span class="cov8" title="1">var eventTrackers []nativeResponse.EventTracker
        if content.Monitor != nil </span><span class="cov8" title="1">{
                for _, monitor := range content.Monitor </span><span class="cov8" title="1">{
                        if len(monitor.Url) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if monitor.EventType == "click" </span><span class="cov8" title="1">{
                                linkObject.ClickTrackers = append(linkObject.ClickTrackers, monitor.Url...)
                        }</span>
                        <span class="cov8" title="1">if monitor.EventType == "imp" </span><span class="cov8" title="1">{
                                for i := range monitor.Url </span><span class="cov8" title="1">{
                                        var eventTracker nativeResponse.EventTracker
                                        eventTracker.Event = native1.EventTypeImpression
                                        eventTracker.Method = native1.EventTrackingMethodImage
                                        eventTracker.URL = monitor.Url[i]
                                        eventTrackers = append(eventTrackers, eventTracker)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">nativeResult.EventTrackers = eventTrackers
        nativeResult.Link = linkObject
        nativeResult.Ver = "1.1"
        if nativePayload.Ver != "" </span><span class="cov8" title="1">{
                nativeResult.Ver = nativePayload.Ver
        }</span>

        <span class="cov8" title="1">var result []byte
        if result, err = jsonEncode(nativeResult); err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, err
        }</span>
        <span class="cov8" title="1">return strings.Replace(string(result), "\n", "", -1), adWidth, adHeight, nil</span>
}

func getDecodeValue(str string) string <span class="cov8" title="1">{
        if str == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if decodeValue, err := url.QueryUnescape(str); err == nil </span><span class="cov8" title="1">{
                return decodeValue
        }</span> else<span class="cov0" title="0"> {
                return ""
        }</span>
}

func jsonEncode(nativeResult nativeResponse.Response) ([]byte, error) <span class="cov8" title="1">{
        buffer := &amp;bytes.Buffer{}
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err := encoder.Encode(nativeResult)
        return buffer.Bytes(), err
}</span>

// extractAdmPicture: For banner single picture
func (a *adapter) extractAdmPicture(content *content) (adm string, adWidth int64, adHeight int64, err error) <span class="cov8" title="1">{
        if content == nil </span><span class="cov0" title="0">{
                return "", 0, 0, errors.New("extract Adm failed: content is empty")
        }</span>

        <span class="cov8" title="1">var clickUrl = ""
        clickUrl, err = a.getClickUrl(content)
        if err != nil </span><span class="cov8" title="1">{
                return "", 0, 0, err
        }</span>

        <span class="cov8" title="1">var imageInfoUrl string
        if content.MetaData.ImageInfo != nil </span><span class="cov8" title="1">{
                imageInfoUrl = content.MetaData.ImageInfo[0].Url
                adHeight = content.MetaData.ImageInfo[0].Height
                adWidth = content.MetaData.ImageInfo[0].Width
        }</span> else<span class="cov0" title="0"> {
                return "", 0, 0, errors.New("content.MetaData.ImageInfo is empty")
        }</span>

        <span class="cov8" title="1">var imageTitle = ""
        imageTitle = getDecodeValue(content.MetaData.Title)
        // dspImp, Imp, dspClick, Click tracking all can be found in MonitorUrl(imp ,click)
        dspImpTrackings, dspClickTrackings := getDspImpClickTrackings(content)
        var dspImpTrackings2StrImg strings.Builder
        for i := 0; i &lt; len(dspImpTrackings); i++ </span><span class="cov8" title="1">{
                dspImpTrackings2StrImg.WriteString(`&lt;img height="1" width="1" src='`)
                dspImpTrackings2StrImg.WriteString(dspImpTrackings[i])
                dspImpTrackings2StrImg.WriteString(`' &gt;  `)
        }</span>

        <span class="cov8" title="1">adm = "&lt;style&gt; html, body  " +
                "{ margin: 0; padding: 0; width: 100%; height: 100%; vertical-align: middle; }  " +
                "html  " +
                "{ display: table; }  " +
                "body { display: table-cell; vertical-align: middle; text-align: center; -webkit-text-size-adjust: none; }  " +
                "&lt;/style&gt; " +
                `&lt;span class="title-link advertiser_label"&gt;` + imageTitle + "&lt;/span&gt; " +
                "&lt;a href='" + clickUrl + `' style="text-decoration:none" ` +
                "onclick=sendGetReq()&gt; " +
                "&lt;img src='" + imageInfoUrl + "' width='" + strconv.Itoa(int(adWidth)) + "' height='" + strconv.Itoa(int(adHeight)) + "'/&gt; " +
                "&lt;/a&gt; " +
                dspImpTrackings2StrImg.String() +
                `&lt;script type="text/javascript"&gt;` +
                "var dspClickTrackings = [" + dspClickTrackings + "];" +
                "function sendGetReq() {" +
                "sendSomeGetReq(dspClickTrackings)" +
                "}" +
                "function sendOneGetReq(url) {" +
                "var req = new XMLHttpRequest();" +
                "req.open('GET', url, true);" +
                "req.send(null);" +
                "}" +
                "function sendSomeGetReq(urls) {" +
                "for (var i = 0; i &lt; urls.length; i++) {" +
                "sendOneGetReq(urls[i]);" +
                "}" +
                "}" +
                "&lt;/script&gt;"
        return adm, adWidth, adHeight, nil</span>
}

// for Interactiontype == appPromotion, clickUrl is intent
func (a *adapter) getClickUrl(content *content) (clickUrl string, err error) <span class="cov8" title="1">{
        if content.Interactiontype == appPromotion </span><span class="cov8" title="1">{
                if content.MetaData.Intent != "" </span><span class="cov8" title="1">{
                        clickUrl = getDecodeValue(content.MetaData.Intent)
                }</span> else<span class="cov8" title="1"> {
                        return "", errors.New("content.MetaData.Intent in huaweiads resopnse is empty when interactiontype is appPromotion")
                }</span>
        } else<span class="cov8" title="1"> {
                if content.MetaData.ClickUrl != "" </span><span class="cov8" title="1">{
                        clickUrl = content.MetaData.ClickUrl
                }</span> else<span class="cov8" title="1"> if content.MetaData.Intent != "" </span><span class="cov8" title="1">{
                        clickUrl = getDecodeValue(content.MetaData.Intent)
                }</span>
        }
        <span class="cov8" title="1">return clickUrl, nil</span>
}

func getDspImpClickTrackings(content *content) (dspImpTrackings []string, dspClickTrackings string) <span class="cov8" title="1">{
        for _, monitor := range content.Monitor </span><span class="cov8" title="1">{
                if len(monitor.Url) != 0 </span><span class="cov8" title="1">{
                        switch monitor.EventType </span>{
                        case "imp":<span class="cov8" title="1">
                                dspImpTrackings = monitor.Url</span>
                        case "click":<span class="cov8" title="1">
                                dspClickTrackings = getStrings(monitor.Url)</span>
                        }
                }
        }
        <span class="cov8" title="1">return dspImpTrackings, dspClickTrackings</span>
}

func getStrings(eles []string) string <span class="cov8" title="1">{
        if len(eles) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">var strs strings.Builder
        for i := 0; i &lt; len(eles); i++ </span><span class="cov8" title="1">{
                strs.WriteString("\"" + eles[i] + "\"")
                if i &lt; len(eles)-1 </span><span class="cov8" title="1">{
                        strs.WriteString(",")
                }</span>
        }
        <span class="cov8" title="1">return strs.String()</span>
}

// getDuration: millisecond -&gt; format: 00:00:00.000
func getDuration(duration int64) string <span class="cov8" title="1">{
        var dur time.Duration = time.Duration(duration) * time.Millisecond
        t := time.Time{}.Add(dur)
        return t.Format("15:04:05.000")
}</span>

// extractAdmVideo: get field adm for video, vast 3.0
func (a *adapter) extractAdmVideo(adType int32, content *content, bidType openrtb_ext.BidType, opentrb2Imp openrtb2.Imp) (adm string,
        adWidth int64, adHeight int64, err error) <span class="cov8" title="1">{
        if content == nil </span><span class="cov0" title="0">{
                return "", 0, 0, errors.New("extract Adm for video failed: content is empty")
        }</span>

        <span class="cov8" title="1">var clickUrl = ""
        clickUrl, err = a.getClickUrl(content)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, 0, err
        }</span>

        <span class="cov8" title="1">var mime = "video/mp4"
        var resourceUrl = ""
        var duration = ""
        if adType == roll </span><span class="cov8" title="1">{
                // roll ad get information from mediafile
                if content.MetaData.MediaFile.Mime != "" </span><span class="cov8" title="1">{
                        mime = content.MetaData.MediaFile.Mime
                }</span>
                <span class="cov8" title="1">adWidth = content.MetaData.MediaFile.Width
                adHeight = content.MetaData.MediaFile.Height
                if content.MetaData.MediaFile.Url != "" </span><span class="cov8" title="1">{
                        resourceUrl = content.MetaData.MediaFile.Url
                }</span> else<span class="cov0" title="0"> {
                        return "", 0, 0, errors.New("extract Adm for video failed: Content.MetaData.MediaFile.Url is empty")
                }</span>
                <span class="cov8" title="1">duration = getDuration(content.MetaData.Duration)</span>
        } else<span class="cov8" title="1"> {
                if content.MetaData.VideoInfo.VideoDownloadUrl != "" </span><span class="cov8" title="1">{
                        resourceUrl = content.MetaData.VideoInfo.VideoDownloadUrl
                }</span> else<span class="cov0" title="0"> {
                        return "", 0, 0, errors.New("extract Adm for video failed: content.MetaData.VideoInfo.VideoDownloadUrl is empty")
                }</span>
                <span class="cov8" title="1">if content.MetaData.VideoInfo.Width != 0 &amp;&amp; content.MetaData.VideoInfo.Height != 0 </span><span class="cov8" title="1">{
                        adWidth = int64(content.MetaData.VideoInfo.Width)
                        adHeight = int64(content.MetaData.VideoInfo.Height)
                }</span> else<span class="cov0" title="0"> if bidType == openrtb_ext.BidTypeVideo </span><span class="cov0" title="0">{
                        if opentrb2Imp.Video != nil &amp;&amp; opentrb2Imp.Video.W != 0 &amp;&amp; opentrb2Imp.Video.H != 0 </span><span class="cov0" title="0">{
                                adWidth = opentrb2Imp.Video.W
                                adHeight = opentrb2Imp.Video.H
                        }</span>
                } else<span class="cov0" title="0"> {
                        return "", 0, 0, errors.New("extract Adm for video failed: cannot get video width, height")
                }</span>
                <span class="cov8" title="1">duration = getDuration(int64(content.MetaData.VideoInfo.VideoDuration))</span>
        }

        <span class="cov8" title="1">var adTitle = getDecodeValue(content.MetaData.Title)
        var adId = content.Contentid
        var creativeId = content.Contentid
        var trackingEvents strings.Builder
        var dspImpTracking2Str = ""
        var dspClickTracking2Str = ""
        var errorTracking2Str = ""
        for _, monitor := range content.Monitor </span><span class="cov8" title="1">{
                if len(monitor.Url) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">var event = ""
                switch monitor.EventType </span>{
                case "vastError":<span class="cov8" title="1">
                        errorTracking2Str = getVastImpClickErrorTrackingUrls(monitor.Url, "vastError")</span>
                case "imp":<span class="cov8" title="1">
                        dspImpTracking2Str = getVastImpClickErrorTrackingUrls(monitor.Url, "imp")</span>
                case "click":<span class="cov8" title="1">
                        dspClickTracking2Str = getVastImpClickErrorTrackingUrls(monitor.Url, "click")</span>
                case "userclose":<span class="cov8" title="1">
                        event = "skip&amp;closeLinear"</span>
                case "playStart":<span class="cov8" title="1">
                        event = "start"</span>
                case "playEnd":<span class="cov8" title="1">
                        event = "complete"</span>
                case "playResume":<span class="cov8" title="1">
                        event = "resume"</span>
                case "playPause":<span class="cov8" title="1">
                        event = "pause"</span>
                case "soundClickOff":<span class="cov0" title="0">
                        event = "mute"</span>
                case "soundClickOn":<span class="cov0" title="0">
                        event = "unmute"</span>
                default:<span class="cov8" title="1"></span>
                }
                <span class="cov8" title="1">if event != "" </span><span class="cov8" title="1">{
                        if event != "skip&amp;closeLinear" </span><span class="cov8" title="1">{
                                trackingEvents.WriteString(getVastEventTrackingUrls(monitor.Url, event))
                        }</span> else<span class="cov8" title="1"> {
                                trackingEvents.WriteString(getVastEventTrackingUrls(monitor.Url, "skip&amp;closeLinear"))
                        }</span>
                }
        }

        // Only for rewarded video
        <span class="cov8" title="1">var rewardedVideoPart = ""
        var isAddRewardedVideoPart = true
        if adType == rewarded </span><span class="cov8" title="1">{
                var staticImageUrl = ""
                var staticImageHeight = ""
                var staticImageWidth = ""
                var staticImageType = "image/png"
                if len(content.MetaData.Icon) &gt; 0 &amp;&amp; content.MetaData.Icon[0].Url != "" </span><span class="cov8" title="1">{
                        staticImageUrl = content.MetaData.Icon[0].Url
                        if content.MetaData.Icon[0].Height &gt; 0 &amp;&amp; content.MetaData.Icon[0].Width &gt; 0 </span><span class="cov8" title="1">{
                                staticImageHeight = strconv.Itoa(int(content.MetaData.Icon[0].Height))
                                staticImageWidth = strconv.Itoa(int(content.MetaData.Icon[0].Width))
                        }</span> else<span class="cov8" title="1"> {
                                staticImageHeight = strconv.Itoa(int(adHeight))
                                staticImageWidth = strconv.Itoa(int(adWidth))
                        }</span>
                } else<span class="cov8" title="1"> if len(content.MetaData.ImageInfo) &gt; 0 &amp;&amp; content.MetaData.ImageInfo[0].Url != "" </span><span class="cov8" title="1">{
                        staticImageUrl = content.MetaData.ImageInfo[0].Url
                        if content.MetaData.ImageInfo[0].Height &gt; 0 &amp;&amp; content.MetaData.ImageInfo[0].Width &gt; 0 </span><span class="cov8" title="1">{
                                staticImageHeight = strconv.Itoa(int(content.MetaData.ImageInfo[0].Height))
                                staticImageWidth = strconv.Itoa(int(content.MetaData.ImageInfo[0].Width))
                        }</span> else<span class="cov8" title="1"> {
                                staticImageHeight = strconv.Itoa(int(adHeight))
                                staticImageWidth = strconv.Itoa(int(adWidth))
                        }</span>
                } else<span class="cov8" title="1"> {
                        isAddRewardedVideoPart = false
                }</span>
                <span class="cov8" title="1">if isAddRewardedVideoPart </span><span class="cov8" title="1">{
                        rewardedVideoPart = `&lt;Creative adId="` + adId + `" id="` + creativeId + `"&gt;` +
                                "&lt;CompanionAds&gt;" +
                                `&lt;Companion width="` + staticImageWidth + `" height="` + staticImageHeight + `"&gt;` +
                                `&lt;StaticResource creativeType="` + staticImageType + `"&gt;&lt;![CDATA[` + staticImageUrl + `]]&gt;&lt;/StaticResource&gt;` +
                                "&lt;CompanionClickThrough&gt;&lt;![CDATA[" + clickUrl + "]]&gt;&lt;/CompanionClickThrough&gt;" +
                                "&lt;/Companion&gt;" +
                                "&lt;/CompanionAds&gt;" +
                                "&lt;/Creative&gt;"
                }</span>
        }

        <span class="cov8" title="1">adm = `&lt;?xml version="1.0" encoding="UTF-8"?&gt;` +
                `&lt;VAST version="3.0"&gt;` +
                `&lt;Ad id="` + adId + `"&gt;&lt;InLine&gt;` +
                "&lt;AdSystem&gt;HuaweiAds&lt;/AdSystem&gt;" +
                "&lt;AdTitle&gt;" + adTitle + "&lt;/AdTitle&gt;" +
                errorTracking2Str + dspImpTracking2Str +
                "&lt;Creatives&gt;" +
                `&lt;Creative adId="` + adId + `" id="` + creativeId + `"&gt;` +
                "&lt;Linear&gt;" +
                "&lt;Duration&gt;" + duration + "&lt;/Duration&gt;" +
                "&lt;TrackingEvents&gt;" + trackingEvents.String() + "&lt;/TrackingEvents&gt;" +
                "&lt;VideoClicks&gt;" +
                "&lt;ClickThrough&gt;&lt;![CDATA[" + clickUrl + "]]&gt;&lt;/ClickThrough&gt;" +
                dspClickTracking2Str +
                "&lt;/VideoClicks&gt;" +
                "&lt;MediaFiles&gt;" +
                `&lt;MediaFile delivery="progressive" type="` + mime + `" width="` + strconv.Itoa(int(adWidth)) + `" ` +
                `height="` + strconv.Itoa(int(adHeight)) + `" scalable="true" maintainAspectRatio="true"&gt; ` +
                "&lt;![CDATA[" + resourceUrl + "]]&gt;" +
                "&lt;/MediaFile&gt;" +
                "&lt;/MediaFiles&gt;" +
                "&lt;/Linear&gt;" +
                "&lt;/Creative&gt;" + rewardedVideoPart +
                "&lt;/Creatives&gt;" +
                "&lt;/InLine&gt;" +
                "&lt;/Ad&gt;" +
                "&lt;/VAST&gt;"
        return adm, adWidth, adHeight, nil</span>
}

func getVastImpClickErrorTrackingUrls(urls []string, eventType string) (result string) <span class="cov8" title="1">{
        var trackingUrls strings.Builder
        for _, url := range urls </span><span class="cov8" title="1">{
                if eventType == "click" </span><span class="cov8" title="1">{
                        trackingUrls.WriteString("&lt;ClickTracking&gt;&lt;![CDATA[")
                        trackingUrls.WriteString(url)
                        trackingUrls.WriteString("]]&gt;&lt;/ClickTracking&gt;")
                }</span> else<span class="cov8" title="1"> if eventType == "imp" </span><span class="cov8" title="1">{
                        trackingUrls.WriteString("&lt;Impression&gt;&lt;![CDATA[")
                        trackingUrls.WriteString(url)
                        trackingUrls.WriteString("]]&gt;&lt;/Impression&gt;")
                }</span> else<span class="cov8" title="1"> if eventType == "vastError" </span><span class="cov8" title="1">{
                        trackingUrls.WriteString("&lt;Error&gt;&lt;![CDATA[")
                        trackingUrls.WriteString(url)
                        trackingUrls.WriteString("&amp;et=[ERRORCODE]]]&gt;&lt;/Error&gt;")
                }</span>
        }
        <span class="cov8" title="1">return trackingUrls.String()</span>
}

func getVastEventTrackingUrls(urls []string, eventType string) (result string) <span class="cov8" title="1">{
        var trackingUrls strings.Builder
        for _, eventUrl := range urls </span><span class="cov8" title="1">{
                if eventType == "skip&amp;closeLinear" </span><span class="cov8" title="1">{
                        trackingUrls.WriteString(`&lt;Tracking event="skip"&gt;&lt;![CDATA[`)
                        trackingUrls.WriteString(eventUrl)
                        trackingUrls.WriteString(`]]&gt;&lt;/Tracking&gt;&lt;Tracking event="closeLinear"&gt;&lt;![CDATA[`)
                        trackingUrls.WriteString(eventUrl)
                        trackingUrls.WriteString("]]&gt;&lt;/Tracking&gt;")
                }</span> else<span class="cov8" title="1"> {
                        trackingUrls.WriteString(`&lt;Tracking event="`)
                        trackingUrls.WriteString(eventType)
                        trackingUrls.WriteString(`"&gt;&lt;![CDATA[`)
                        trackingUrls.WriteString(eventUrl)
                        trackingUrls.WriteString("]]&gt;&lt;/Tracking&gt;")
                }</span>
        }
        <span class="cov8" title="1">return trackingUrls.String()</span>
}

func computeHmacSha256(message string, signKey string) string <span class="cov8" title="1">{
        h := hmac.New(sha256.New, []byte(signKey))
        h.Write([]byte(message))
        return hex.EncodeToString(h.Sum(nil))
}</span>

// getDigestAuthorization: get digest authorization for request header
func getDigestAuthorization(huaweiAdsImpExt *openrtb_ext.ExtImpHuaweiAds, isTestAuthorization bool) string <span class="cov8" title="1">{
        var nonce = strconv.FormatInt(time.Now().UnixNano()/1e6, 10)
        // this is for test case, time 2021/8/20 19:30
        if isTestAuthorization </span><span class="cov8" title="1">{
                nonce = "1629473330823"
        }</span>
        <span class="cov8" title="1">publisher_id := strings.TrimSpace(huaweiAdsImpExt.PublisherId)
        sign_key := strings.TrimSpace(huaweiAdsImpExt.SignKey)
        key_id := strings.TrimSpace(huaweiAdsImpExt.KeyId)

        var apiKey = publisher_id + ":ppsadx/getResult:" + sign_key
        return "Digest username=" + publisher_id + "," +
                "realm=ppsadx/getResult," +
                "nonce=" + nonce + "," +
                "response=" + computeHmacSha256(nonce+":POST:/ppsadx/getResult", apiKey) + "," +
                "algorithm=HmacSHA256,usertype=1,keyid=" + key_id</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
